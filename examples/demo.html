<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Multi-Shader Background Demo</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: white;
            overflow-x: hidden;
        }

        #bg-canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: fixed;
            inset: 0;
            transition: opacity 0.3s ease-out;
        }

        /* Shader indicator */
        #shader-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 10px 18px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #shader-indicator.transitioning {
            opacity: 0.5;
        }

        /* Sections */
        .section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 100px 40px 60px;
        }

        .section-content {
            text-align: center;
            position: relative;
            z-index: 1;
            max-width: 900px;
        }

        h1 {
            font-size: clamp(2.5rem, 7vw, 6rem);
            font-weight: 800;
            line-height: 1;
            margin-bottom: 24px;
            text-shadow: 2px 2px 20px rgba(0, 0, 0, 0.9);
            letter-spacing: -0.02em;
        }

        .section-desc {
            font-size: clamp(1.1rem, 2.5vw, 1.8rem);
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 8px rgba(0, 0, 0, 0.9);
            margin-bottom: 16px;
            font-weight: 400;
            line-height: 1.4;
        }

        .shader-badge {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(117, 73, 167, 0.35);
            border: 1px solid rgba(117, 73, 167, 0.6);
            border-radius: 24px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 12px;
        }

        /* Buffer sections for transitions */
        .buffer-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to bottom,
                    transparent 0%,
                    rgba(0, 0, 0, 0.4) 50%,
                    transparent 100%);
        }

        .buffer-content {
            text-align: center;
            color: rgba(255, 255, 255, 0.35);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
        }

        /* Scroll hint */
        .scroll-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            font-weight: 500;
            animation: bounce 2.5s infinite;
            letter-spacing: 1px;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translate(-50%, 0);
            }

            50% {
                transform: translate(-50%, 12px);
            }
        }
    </style>
</head>

<body>
    <canvas id="bg-canvas"></canvas>

    <!-- Shader indicator -->
    <div id="shader-indicator">Loading...</div>


    <!-- GS1 Mode Transition Test Sections -->
    <div class="section" data-shader-system="gs1" data-shader-preset="hero" data-shader-mode="atmospheric-mesh"
        data-cursor-global="0.0" data-flatten="0.0" data-height-contrast="1.0" data-warp-intensity="1.0">
        <div class="section-content">
            <h1>Atmospheric Mesh ¬∑ Hero</h1>
            <p class="section-desc">Flowing gradient field ‚Ä¢ Maximum spatial variation ‚Ä¢ Dynamic atmosphere</p>
            <span class="shader-badge">GS1 ‚Ä¢ Atmospheric Mesh ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="ambient" data-shader-mode="atmospheric-mesh"
        data-cursor-global="0.0" data-flatten="0.35" data-height-contrast="0.6" data-warp-intensity="1.0">
        <div class="section-content">
            <h1>Atmospheric Mesh ¬∑ Ambient</h1>
            <p class="section-desc">Balanced gradient flow ‚Ä¢ Moderate motion ‚Ä¢ Comfortable presence</p>
            <span class="shader-badge">GS1 ‚Ä¢ Atmospheric Mesh ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="read" data-shader-mode="atmospheric-mesh"
        data-cursor-global="0.0" data-flatten="0.85" data-height-contrast="0.25" data-warp-intensity="1.0">
        <div class="section-content">
            <h1>Atmospheric Mesh ¬∑ Read</h1>
            <p class="section-desc">Gentle subtle gradient ‚Ä¢ Minimal distraction ‚Ä¢ Reading-optimized</p>
            <span class="shader-badge">GS1 ‚Ä¢ Atmospheric Mesh ‚Ä¢ Read</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="hero" data-shader-mode="topographic-flow"
        data-cursor-global="0.0" data-flatten="0.0" data-height-contrast="1.0" data-warp-intensity="1.0"
        data-topo-bands="20.0" data-topo-white-bias="0.0">
        <div class="section-content">
            <h1>Topographic Flow ¬∑ Hero</h1>
            <p class="section-desc">High contrast contour lines ‚Ä¢ Dynamic topographic mapping ‚Ä¢ Bold elevation flow</p>
            <span class="shader-badge">GS1 ‚Ä¢ Topographic Flow ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="ambient" data-shader-mode="topographic-flow"
        data-cursor-global="0.0" data-flatten="0.35" data-height-contrast="0.6" data-warp-intensity="1.0"
        data-topo-bands="15.0" data-topo-white-bias="0.0">
        <div class="section-content">
            <h1>Topographic Flow ¬∑ Ambient</h1>
            <p class="section-desc">Balanced contour definition ‚Ä¢ Moderate topographic detail ‚Ä¢ Elegant mapping</p>
            <span class="shader-badge">GS1 ‚Ä¢ Topographic Flow ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="read" data-shader-mode="topographic-flow"
        data-cursor-global="0.0" data-flatten="0.85" data-height-contrast="0.25" data-warp-intensity="1.0"
        data-topo-bands="10.0" data-topo-white-bias="0.0">
        <div class="section-content">
            <h1>Topographic Flow ¬∑ Read</h1>
            <p class="section-desc">Subtle contour hints ‚Ä¢ Low contrast lines ‚Ä¢ Background topography</p>
            <span class="shader-badge">GS1 ‚Ä¢ Topographic Flow ‚Ä¢ Read</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="hero" data-shader-mode="fabric-warp"
        data-cursor-global="0.0" data-flatten="0.0" data-height-contrast="1.0" data-warp-intensity="1.0"
        data-organic-backlight="1.0" data-organic-darkening="1.0">
        <div class="section-content">
            <h1>Fabric Warp ¬∑ Hero</h1>
            <p class="section-desc">Rich organic texture ‚Ä¢ Deep material complexity ‚Ä¢ Dynamic light/shadow interplay</p>
            <span class="shader-badge">GS1 ‚Ä¢ Fabric Warp ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="ambient" data-shader-mode="fabric-warp"
        data-cursor-global="0.0" data-flatten="0.35" data-height-contrast="0.6" data-warp-intensity="1.0"
        data-organic-backlight="0.7" data-organic-darkening="0.7">
        <div class="section-content">
            <h1>Fabric Warp ¬∑ Ambient</h1>
            <p class="section-desc">Balanced material texture ‚Ä¢ Moderate surface detail ‚Ä¢ Natural fabric feel</p>
            <span class="shader-badge">GS1 ‚Ä¢ Fabric Warp ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs1" data-shader-preset="read" data-shader-mode="fabric-warp"
        data-cursor-global="0.0" data-flatten="0.85" data-height-contrast="0.25" data-warp-intensity="1.0"
        data-organic-backlight="0.3" data-organic-darkening="0.3">
        <div class="section-content">
            <h1>Fabric Warp ¬∑ Read</h1>
            <p class="section-desc">Subtle material presence ‚Ä¢ Minimal texture noise ‚Ä¢ Calm organic background</p>
            <span class="shader-badge">GS1 ‚Ä¢ Fabric Warp ‚Ä¢ Read</span>
        </div>
    </div>


    <!-- Transition buffer -->
    <div class="buffer-section">
        <div class="buffer-content">‚Äî Transitioning to GS2 Glitch Technical ‚Äî</div>
    </div>

    <!-- ========================================= -->
    <!-- GS2: GLITCH TECHNICAL SHADER (9 sections) -->
    <!-- ========================================= -->

    <!-- Glitch Grid Mode -->
    <div class="section" data-shader-system="gs2" data-shader-preset="hero" data-shader-mode="glitch-grid"
        data-flow-dir="0deg" data-grid-line-width="1.5" data-grid-fill-amount="0.8"
        data-grid-cursor-fills="1.8" data-grid-subdivision-depth="1.4" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Glitch Grid ¬∑ Hero</h1>
            <p class="section-desc">Maximum disruption ‚Ä¢ Geometric fragmentation ‚Ä¢ Digital chaos</p>
            <span class="shader-badge">GS2 ‚Ä¢ Glitch Grid ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="ambient" data-shader-mode="glitch-grid"
        data-flow-dir="45deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Glitch Grid ¬∑ Ambient</h1>
            <p class="section-desc">Moderate glitch artifacts ‚Ä¢ Balanced grid distortion ‚Ä¢ Technical aesthetic</p>
            <span class="shader-badge">GS2 ‚Ä¢ Glitch Grid ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="read" data-shader-mode="glitch-grid"
        data-flow-dir="90deg" data-grid-line-width="0.7" data-grid-fill-amount="0.3"
        data-grid-cursor-fills="0.4" data-grid-subdivision-depth="0.5" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Glitch Grid ¬∑ Read</h1>
            <p class="section-desc">Subtle grid artifacts ‚Ä¢ Minimal disruption ‚Ä¢ Readable background</p>
            <span class="shader-badge">GS2 ‚Ä¢ Glitch Grid ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- Vector Glitch Mode -->
    <div class="section" data-shader-system="gs2" data-shader-preset="hero" data-shader-mode="vector-glitch"
        data-flow-dir="45deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.5" data-shard-speed="1.5"
        data-shard-chaos="1.5" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Vector Glitch ¬∑ Hero</h1>
            <p class="section-desc">Directional data corruption ‚Ä¢ Sharp vector artifacts ‚Ä¢ High intensity</p>
            <span class="shader-badge">GS2 ‚Ä¢ Vector Glitch ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="ambient" data-shader-mode="vector-glitch"
        data-flow-dir="45deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Vector Glitch ¬∑ Ambient</h1>
            <p class="section-desc">Balanced vector flow ‚Ä¢ Controlled distortion ‚Ä¢ Technical elegance</p>
            <span class="shader-badge">GS2 ‚Ä¢ Vector Glitch ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="read" data-shader-mode="vector-glitch"
        data-flow-dir="90deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="0.6" data-shard-speed="0.5"
        data-shard-chaos="0.5" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Vector Glitch ¬∑ Read</h1>
            <p class="section-desc">Gentle vector hints ‚Ä¢ Subtle directional flow ‚Ä¢ Calm technical presence</p>
            <span class="shader-badge">GS2 ‚Ä¢ Vector Glitch ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- Signal Flow Mode -->
    <div class="section" data-shader-system="gs2" data-shader-preset="hero" data-shader-mode="signal-flow"
        data-flow-dir="0deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.3" data-flow-warp="1.5">
        <div class="section-content">
            <h1>Signal Flow ¬∑ Hero</h1>
            <p class="section-desc">Data stream visualization ‚Ä¢ High bandwidth ‚Ä¢ Information overload</p>
            <span class="shader-badge">GS2 ‚Ä¢ Signal Flow ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="ambient" data-shader-mode="signal-flow"
        data-flow-dir="90deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="1.0" data-flow-warp="1.0">
        <div class="section-content">
            <h1>Signal Flow ¬∑ Ambient</h1>
            <p class="section-desc">Moderate data transmission ‚Ä¢ Steady signal ‚Ä¢ Technical balance</p>
            <span class="shader-badge">GS2 ‚Ä¢ Signal Flow ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs2" data-shader-preset="read" data-shader-mode="signal-flow"
        data-flow-dir="90deg" data-grid-line-width="1.0" data-grid-fill-amount="0.5"
        data-grid-cursor-fills="1.0" data-grid-subdivision-depth="1.0" data-shard-count="1.0" data-shard-speed="1.0"
        data-shard-chaos="1.0" data-flow-density="0.7" data-flow-warp="0.6">
        <div class="section-content">
            <h1>Signal Flow ¬∑ Read</h1>
            <p class="section-desc">Minimal signal noise ‚Ä¢ Quiet data presence ‚Ä¢ Reading-optimized</p>
            <span class="shader-badge">GS2 ‚Ä¢ Signal Flow ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- Transition buffer -->
    <div class="buffer-section">
        <div class="buffer-content">‚Äî Transitioning to GS3 Dot Field ‚Äî</div>
    </div>

    <!-- ========================================= -->
    <!-- GS3: DOT FIELD SHADER (6 sections) -->
    <!-- ========================================= -->

    <!-- Perlin Dot Field Mode -->
    <div class="section" data-shader-system="gs3" data-shader-preset="hero" data-shader-mode="perlin-dot-field"
        data-k-grid="0.5" data-k-jitter="0.35" data-k-size="0.5" data-k-lane="0.5" data-k-wobble="0.5"
        data-k-alpha="0.9">
        <div class="section-content">
            <h1>Perlin Dot Field ¬∑ Hero</h1>
            <p class="section-desc">Organic particle clustering ‚Ä¢ Natural noise distribution ‚Ä¢ High density</p>
            <span class="shader-badge">GS3 ‚Ä¢ Perlin Dot Field ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="ambient" data-shader-mode="perlin-dot-field"
        data-k-grid="0.6" data-k-jitter="0.5" data-k-size="0.6" data-k-lane="0.5" data-k-wobble="0.6"
        data-k-alpha="1.0">
        <div class="section-content">
            <h1>Perlin Dot Field ¬∑ Ambient</h1>
            <p class="section-desc">Balanced particle distribution ‚Ä¢ Moderate density ‚Ä¢ Natural flow</p>
            <span class="shader-badge">GS3 ‚Ä¢ Perlin Dot Field ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="read" data-shader-mode="perlin-dot-field"
        data-k-grid="0.5" data-k-jitter="1.0" data-k-size="1.0" data-k-lane="1.0" data-k-wobble="0.92"
        data-k-alpha="1.0">
        <div class="section-content">
            <h1>Perlin Dot Field ¬∑ Read</h1>
            <p class="section-desc">Sparse organic particles ‚Ä¢ Minimal spatial noise ‚Ä¢ Reading-friendly</p>
            <span class="shader-badge">GS3 ‚Ä¢ Perlin Dot Field ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- Kusama Infinite Mode -->
    <div class="section" data-shader-system="gs3" data-shader-preset="hero" data-shader-mode="kusama-infinite"
        data-k-grid="0.5" data-k-jitter="1.0" data-k-size="0.5" data-k-lane="0.8" data-k-wobble="0.92"
        data-k-alpha="1.0" data-debug-colors="0.0">
        <div class="section-content">
            <h1>Kusama Infinite ¬∑ Hero</h1>
            <p class="section-desc">Dense polka dot installation ‚Ä¢ Artistic infinity ‚Ä¢ Bold presence</p>
            <span class="shader-badge">GS3 ‚Ä¢ Kusama Infinite ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="ambient" data-shader-mode="kusama-infinite"
        data-k-grid="0.6" data-k-jitter="1.0" data-k-size="0.7" data-k-lane="0.9" data-k-wobble="0.92"
        data-k-alpha="1.0" data-debug-colors="0.0">
        <div class="section-content">
            <h1>Kusama Infinite ¬∑ Ambient</h1>
            <p class="section-desc">Moderate dot field ‚Ä¢ Balanced artistic presence ‚Ä¢ Contemplative space</p>
            <span class="shader-badge">GS3 ‚Ä¢ Kusama Infinite ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="read" data-shader-mode="kusama-infinite"
        data-k-grid="0.5" data-k-jitter="1.0" data-k-size="1.0" data-k-lane="1.0" data-k-wobble="0.92"
        data-k-alpha="1.0" data-debug-colors="0.0">
        <div class="section-content">
            <h1>Kusama Infinite ¬∑ Read</h1>
            <p class="section-desc">Meditative dot composition ‚Ä¢ Serene infinity room ‚Ä¢ Perfect for focus</p>
            <span class="shader-badge">GS3 ‚Ä¢ Kusama Infinite ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- GS3 Mode 2: Octopus Legs -->
    <div class="buffer-section">
        <div class="buffer-content">‚Üì GS3 Mode 2: Octopus Legs ‚Üì</div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="hero" data-shader-mode="octopus-legs"
        data-k-grid="0.5" data-k-jitter="0.65" data-k-size="0.38" data-k-lane="0.55" data-k-wobble="0.75"
        data-k-alpha="0.8" data-k-curve-amp="0.85" data-k-curve-variety="0.9" data-debug-colors="0.0">
        <div class="section-content">
            <h1>üêô Octopus Legs ¬∑ Hero</h1>
            <p class="section-desc">Curvy organic lanes ‚Ä¢ Flowing tentacles ‚Ä¢ Dynamic overlapping paths</p>
            <span class="shader-badge">GS3 ‚Ä¢ Octopus Legs ‚Ä¢ Hero</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="ambient" data-shader-mode="octopus-legs"
        data-k-grid="0.5" data-k-jitter="0.45" data-k-size="0.55" data-k-lane="0.5" data-k-wobble="0.55"
        data-k-alpha="0.85" data-k-curve-amp="0.65" data-k-curve-variety="0.75" data-debug-colors="0.0">
        <div class="section-content">
            <h1>üêô Octopus Legs ¬∑ Ambient</h1>
            <p class="section-desc">Gentle curves ‚Ä¢ Soft motion ‚Ä¢ Balanced flow</p>
            <span class="shader-badge">GS3 ‚Ä¢ Octopus Legs ‚Ä¢ Ambient</span>
        </div>
    </div>

    <div class="section" data-shader-system="gs3" data-shader-preset="read" data-shader-mode="octopus-legs"
        data-k-grid="0.5" data-k-jitter="0.25" data-k-size="0.7" data-k-lane="0.9" data-k-wobble="0.35"
        data-k-alpha="0.9" data-k-curve-amp="0.45" data-k-curve-variety="0.55" data-debug-colors="0.0">
        <div class="section-content">
            <h1>üêô Octopus Legs ¬∑ Read</h1>
            <p class="section-desc">Subtle undulation ‚Ä¢ Minimal distraction ‚Ä¢ Calm background</p>
            <span class="shader-badge">GS3 ‚Ä¢ Octopus Legs ‚Ä¢ Read</span>
        </div>
    </div>

    <!-- Final buffer -->
    <div class="buffer-section">
        <div class="buffer-content">‚Äî End of Demo ‚Äî</div>
    </div>

    <!-- Universal Config Form Panel (embedded for local testing) -->
    <style>
        #shader-config-panel {
            position: fixed;
            right: 16px;
            bottom: 16px;
            width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 16px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 13px;
            z-index: 9999;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #shader-config-panel.hidden {
            transform: translateX(calc(100% + 32px));
            opacity: 0;
            pointer-events: none;
        }

        #shader-config-panel .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        #shader-config-panel .panel-title {
            font-size: 15px;
            font-weight: 600;
            margin: 0;
        }

        #shader-config-panel .shader-indicator {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(136, 12, 80, 0.4);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #shader-config-panel .close-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.2s;
        }

        #shader-config-panel .close-btn:hover {
            color: #fff;
        }

        #shader-config-panel .control-section {
            display: none;
        }

        #shader-config-panel .control-section.active {
            display: block;
        }

        #shader-config-panel .section-header {
            font-size: 13px;
            font-weight: 600;
            margin: 16px 0 10px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.85;
        }

        #shader-config-panel .section-header:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        #shader-config-panel label {
            display: block;
            margin-bottom: 14px;
        }

        #shader-config-panel label.highlight {
            background: rgba(255, 193, 7, 0.1);
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid rgba(255, 193, 7, 0.6);
        }

        #shader-config-panel .label-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        #shader-config-panel .label-text {
            opacity: 0.8;
            font-size: 12px;
        }

        #shader-config-panel .value-display {
            font-weight: 600;
            font-size: 12px;
            color: rgba(136, 12, 80, 1);
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
        }

        #shader-config-panel input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }

        #shader-config-panel .step-toggle,
        #shader-config-panel .direction-presets,
        #shader-config-panel .density-presets {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        #shader-config-panel .step-toggle label {
            margin: 0;
            display: flex;
            align-items: center;
            font-size: 11px;
            cursor: pointer;
        }

        #shader-config-panel .step-toggle input[type="radio"] {
            margin-right: 4px;
        }

        #shader-config-panel button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            font-weight: 500;
        }

        #shader-config-panel button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        #shader-config-panel button.active {
            background: rgba(136, 12, 80, 0.6);
            border-color: rgba(136, 12, 80, 0.8);
        }

        #shader-config-panel .extra-info {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 4px;
        }

        #shader-config-panel .lane-count {
            font-size: 11px;
            opacity: 0.7;
            margin-left: 8px;
        }

        #config-toggle-btn {
            position: fixed;
            right: 16px;
            bottom: 16px;
            width: 56px;
            height: 56px;
            background: rgba(136, 12, 80, 0.9);
            border: none;
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9998;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        #config-toggle-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #config-toggle-btn:hover {
            background: rgba(136, 12, 80, 1);
            transform: scale(1.05);
        }

        #shader-config-panel::-webkit-scrollbar {
            width: 8px;
        }

        #shader-config-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        #shader-config-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        #shader-config-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .meta-toggle-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .meta-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .meta-toggle-btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .meta-controls {
            display: none;
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meta-controls.visible {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .meta-control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .meta-control-group label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .meta-control-group input {
            width: 100%;
            padding: 4px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 3px;
        }

        .meta-control-group input:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.5);
        }

        .meta-controls-header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meta-controls-header span {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .reset-meta-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reset-meta-btn:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .reset-all-btn {
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: white;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .reset-all-btn:hover {
            background: rgba(245, 158, 11, 0.3);
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 9999;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none !important;
            /* Hidden by default, toggle with 'f' key */
        }

        #fps-counter.show {
            display: block !important;
        }

        #fps-counter .fps-value {
            font-weight: bold;
            font-size: 18px;
        }

        #fps-counter .fps-good {
            color: #10b981;
        }

        #fps-counter .fps-medium {
            color: #f59e0b;
        }

        #fps-counter .fps-bad {
            color: #ef4444;
        }

        #fps-counter .fps-stats {
            font-size: 11px;
            margin-top: 4px;
            opacity: 0.7;
        }
    </style>

    <!-- Config Panel HTML -->
    <div id="fps-counter">
        <div>
            FPS: <span class="fps-value" id="fps-value">--</span>
        </div>
        <div class="fps-stats">
            <div>Min: <span id="fps-min">--</span> | Max: <span id="fps-max">--</span> | Avg: <span
                    id="fps-avg">--</span></div>
        </div>
    </div>

    <div id="shader-config-panel">
        <div class="panel-header">
            <div>
                <h3 class="panel-title">Shader Controls</h3>
                <span class="shader-indicator" id="current-shader-indicator">GS3</span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button class="reset-all-btn" id="reset-all-btn" title="Reset all values and ranges">‚Ü∫ Reset</button>
                <button class="meta-toggle-btn" id="meta-toggle-btn" title="Toggle advanced controls">‚öôÔ∏è</button>
                <button class="close-btn" id="close-panel-btn" title="Close (Ctrl+K)">&times;</button>
            </div>
        </div>

        <!-- GS1 Controls (Topographic) -->
        <div class="control-section" data-shader="gs1">
            <div class="section-header">GS1: Core Visual Controls</div>

            <label>
                <div class="label-header">
                    <span class="label-text">Height Flatten</span>
                    <span class="value-display" data-display="flatten">0.0</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.0" data-uniform="flatten"
                    data-attr="data-flatten">
                <div class="extra-info">Height variation: 0=full peaks/valleys, 1=completely flat</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Height Contrast</span>
                    <span class="value-display" data-display="heightContrast">1.0</span>
                </div>
                <input type="range" min="0" max="2" step="0.01" value="1.0" data-uniform="heightContrast"
                    data-attr="data-height-contrast">
                <div class="extra-info">Terrain contrast: 0=subtle, 1=normal, 2=exaggerated</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Warp Intensity</span>
                    <span class="value-display" data-display="warpIntensity">1.0</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="1.0" data-uniform="warpIntensity"
                    data-attr="data-warp-intensity">
                <div class="extra-info">Field distortion: 0=geometric, 1=organic flow</div>
            </label>

            <div class="section-header" style="margin-top: 20px;">Mode-Specific Controls</div>

            <label data-mode="topographic-flow">
                <div class="label-header">
                    <span class="label-text">Topo Band Count</span>
                    <span class="value-display" data-display="topoBands">20</span>
                </div>
                <input type="range" min="2" max="50" step="1" value="20" data-uniform="topoBands"
                    data-attr="data-topo-bands">
                <div class="extra-info">Contour lines in topographic-flow: 2=broad, 50=fine detail</div>
            </label>

            <label data-mode="topographic-flow">
                <div class="label-header">
                    <span class="label-text">Topo White Bias</span>
                    <span class="value-display" data-display="topoWhiteBias">0.0</span>
                </div>
                <input type="range" min="0" max="0.5" step="0.01" value="0.0" data-uniform="topoWhiteBias"
                    data-attr="data-topo-white-bias">
                <div class="extra-info">White region expansion in topographic-flow: 0=balanced, 0.5=mostly white</div>
            </label>

            <label data-mode="fabric-warp">
                <div class="label-header">
                    <span class="label-text">Organic Backlight</span>
                    <span class="value-display" data-display="organicBacklight">1.0</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="1.0" data-uniform="organicBacklight"
                    data-attr="data-organic-backlight">
                <div class="extra-info">Trough glow in fabric-warp: 0=no glow, 1=full subsurface scattering</div>
            </label>

            <label data-mode="fabric-warp">
                <div class="label-header">
                    <span class="label-text">Organic Darkening</span>
                    <span class="value-display" data-display="organicDarkening">1.0</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="1.0" data-uniform="organicDarkening"
                    data-attr="data-organic-darkening">
                <div class="extra-info">Peak shadows in fabric-warp: 0=no shadows, 1=full charring effect</div>
            </label>
        </div>

        <!-- GS2 Controls (Glitch) -->
        <div class="control-section" data-shader="gs2">
            <div class="section-header">GS2: Core Visual Controls</div>

            <label class="highlight">
                <div class="label-header">
                    <span class="label-text">‚ö° Calm (Motion Intensity)</span>
                    <span class="value-display" data-display="calm">0.45</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.45" data-uniform="calm" data-attr="data-calm"
                    id="gs2-calm-slider">
                <div class="extra-info">Universal control: 0=chaos, 1=calm (affects all modes)</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Flow Direction</span>
                    <span class="value-display" data-display="flowDir">45¬∞</span>
                </div>
                <input type="range" min="0" max="360" step="1" value="45" data-uniform="flowDir"
                    data-attr="data-flow-dir" data-unit="deg">
                <div class="extra-info">Universal control: Directional bias for animation/color (all modes)</div>
            </label>

            <div class="section-header" style="margin-top: 20px;">Mode-Specific Controls</div>

            <label data-mode="glitch-grid">
                <div class="label-header">
                    <span class="label-text">Grid Line Width</span>
                    <span class="value-display" data-display="gridLineWidth">1.0</span>
                </div>
                <input type="range" min="0.5" max="2.5" step="0.1" value="1.0" data-uniform="gridLineWidth"
                    data-attr="data-grid-line-width">
                <div class="extra-info">Line thickness multiplier</div>
            </label>

            <label data-mode="glitch-grid">
                <div class="label-header">
                    <span class="label-text">Grid Fill Amount</span>
                    <span class="value-display" data-display="gridFillAmount">0.5</span>
                </div>
                <input type="range" min="0" max="1" step="0.05" value="0.5" data-uniform="gridFillAmount"
                    data-attr="data-grid-fill-amount">
                <div class="extra-info">(Unused - use Grid Fill Density instead)</div>
            </label>

            <label data-mode="glitch-grid">
                <div class="label-header">
                    <span class="label-text">Grid Cursor Fills</span>
                    <span class="value-display" data-display="gridCursorFills">1.0</span>
                </div>
                <input type="range" min="0" max="2" step="0.1" value="1.0" data-uniform="gridCursorFills"
                    data-attr="data-grid-cursor-fills">
                <div class="extra-info">(Unused - ghosts work via border reveals)</div>
            </label>

            <label data-mode="glitch-grid">
                <div class="label-header">
                    <span class="label-text">Grid Subdivision Depth</span>
                    <span class="value-display" data-display="gridSubdivisionDepth">1.0</span>
                </div>
                <input type="range" min="0.3" max="1.5" step="0.1" value="1.0" data-uniform="gridSubdivisionDepth"
                    data-attr="data-grid-subdivision-depth">
                <div class="extra-info">Cell size (lower=larger rectangles, higher=smaller)</div>
            </label>

            <label data-mode="glitch-grid">
                <div class="label-header">
                    <span class="label-text">Grid Fill Density</span>
                    <span class="value-display" data-display="gridSmallFills">1.0</span>
                </div>
                <input type="range" min="0" max="1" step="0.05" value="1.0" data-uniform="gridSmallFills"
                    data-attr="data-grid-small-fills">
                <div class="extra-info">Colored rectangle density: 0=none, 1=all filled</div>
            </label>

            <label data-mode="vector-glitch">
                <div class="label-header">
                    <span class="label-text">Shard Count</span>
                    <span class="value-display" data-display="shardCount">1.0</span>
                </div>
                <input type="range" min="0.3" max="2.0" step="0.1" value="1.0" data-uniform="shardCount"
                    data-attr="data-shard-count">
                <div class="extra-info">Number of shards per cell</div>
            </label>

            <label data-mode="vector-glitch">
                <div class="label-header">
                    <span class="label-text">Shard Speed</span>
                    <span class="value-display" data-display="shardSpeed">1.0</span>
                </div>
                <input type="range" min="0" max="2" step="0.1" value="1.0" data-uniform="shardSpeed"
                    data-attr="data-shard-speed">
                <div class="extra-info">Animation speed multiplier</div>
            </label>

            <label data-mode="vector-glitch">
                <div class="label-header">
                    <span class="label-text">Shard Chaos</span>
                    <span class="value-display" data-display="shardChaos">1.0</span>
                </div>
                <input type="range" min="0" max="2" step="0.1" value="1.0" data-uniform="shardChaos"
                    data-attr="data-shard-chaos">
                <div class="extra-info">Rotation and irregularity</div>
            </label>

            <label data-mode="signal-flow">
                <div class="label-header">
                    <span class="label-text">Flow Density</span>
                    <span class="value-display" data-display="flowDensity">1.0</span>
                </div>
                <input type="range" min="0.4" max="2" step="0.1" value="1.0" data-uniform="flowDensity"
                    data-attr="data-flow-density">
                <div class="extra-info">Line frequency</div>
            </label>

            <label data-mode="signal-flow">
                <div class="label-header">
                    <span class="label-text">Flow Warp</span>
                    <span class="value-display" data-display="flowWarp">1.0</span>
                </div>
                <input type="range" min="0" max="2" step="0.1" value="1.0" data-uniform="flowWarp"
                    data-attr="data-flow-warp">
                <div class="extra-info">Curvature intensity</div>
            </label>
        </div>

        <!-- GS3 Controls (Kusama Dots) -->
        <div class="control-section active" data-shader="gs3">
            <div class="section-header">Kusama Knobs (Primary)</div>

            <label>
                <div class="label-header">
                    <span class="label-text">Grid Density (Spacing)</span>
                    <span class="value-display" data-display="kGrid">0.5</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.5" data-uniform="kGrid"
                    data-attr="data-k-grid">
                <div class="extra-info">Horizontal spacing: 0=sparse, 1=dense</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Jitter (Organic Scatter)</span>
                    <span class="value-display" data-display="kJitter">0.35</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.35" data-uniform="kJitter"
                    data-attr="data-k-jitter">
                <div class="extra-info">0=grid aligned, 1=hand-painted scatter</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Dot Size</span>
                    <span class="value-display" data-display="kSize">0.55</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.55" data-uniform="kSize"
                    data-attr="data-k-size">
                <div class="extra-info">Base diameter: 0=tiny, 1=large</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Lane Count (Vertical Density)</span>
                    <span class="value-display" data-display="kLaneFreq">0.5<span class="lane-count">7
                            lanes</span></span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.5" data-uniform="kLaneFreq"
                    data-attr="data-k-lane">
                <div class="extra-info">3 to 11 lanes: 0=fewer lanes, 1=more lanes</div>
            </label>

            <label class="highlight">
                <div class="label-header">
                    <span class="label-text">‚ö° Lane Wobble (Motion)</span>
                    <span class="value-display" data-display="kLaneWobble">0.5</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.5" data-uniform="kLaneWobble"
                    data-attr="data-k-wobble" id="gs3-wobble-slider">
                <div class="extra-info">PRIMARY motion control: 0=static, 1=waves</div>
            </label>

            <label>
                <div class="label-header">
                    <span class="label-text">Opacity (Ink Darkness)</span>
                    <span class="value-display" data-display="kAlpha">0.9</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" value="0.9" data-uniform="kAlpha"
                    data-attr="data-k-alpha">
                <div class="extra-info">Dot opacity: 0=invisible, 1=strong</div>
            </label>

            <!-- MODE 2 (Octopus Legs) Controls -->
            <div style="margin-top: 24px; padding-top: 24px; border-top: 2px solid #333;">
                <h3
                    style="margin: 0 0 16px 0; font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px;">
                    üêô Mode 2: Octopus Legs
                </h3>

                <label>
                    <div class="label-header">
                        <span class="label-text">Curve Amplitude (Intensity)</span>
                        <span class="value-display" data-display="kCurveAmp">0.7</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.7" data-uniform="kCurveAmp"
                        data-attr="data-k-curve-amp">
                    <div class="extra-info">Curvature strength: 0=straight, 1=dramatic</div>
                </label>

                <label>
                    <div class="label-header">
                        <span class="label-text">Lane Variety (Uniqueness)</span>
                        <span class="value-display" data-display="kCurveVariety">0.8</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.8" data-uniform="kCurveVariety"
                        data-attr="data-k-curve-variety">
                    <div class="extra-info">Lane independence: 0=synchronized, 1=unique</div>
                </label>

                <label>
                    <div class="label-header">
                        <span class="label-text">Debug Colors</span>
                        <span class="value-display" data-display="debugColors">0.0</span>
                    </div>
                    <input type="range" min="0" max="1" step="1" value="0" data-uniform="debugColors"
                        data-attr="data-debug-colors">
                    <div class="extra-info">0=black dots, 1=colored by scale (brand colors)</div>
                </label>
            </div>
        </div>
    </div>

    <!-- Toggle Button -->
    <button id="config-toggle-btn" title="Open Config Panel (Ctrl+K)">‚öôÔ∏è</button>

    <script src="../src/engine.js"></script>

    <!-- GS1: Topographic shader files -->
    <script src="../src/shaders/gs1/config.js"></script>
    <script src="../src/shaders/gs1/shader.js"></script>
    <script src="../src/shaders/gs1/adaptor.js"></script>

    <!-- GS2: Glitch shader files -->
    <script src="../src/shaders/gs2/config.js"></script>
    <script src="../src/shaders/gs2/shader.js"></script>
    <script src="../src/shaders/gs2/adaptor.js"></script>

    <!-- GS3: Dot Field shader files -->
    <script src="../src/shaders/gs3/config.js"></script>
    <script src="../src/shaders/gs3/shader.js"></script>
    <script src="../src/shaders/gs3/adaptor.js"></script>

    <!-- Scroll-based shader manager -->
    <script src="../src/scroll-manager.js"></script>

    <script>
        // Update shader indicator
        function updateIndicator() {
            const indicator = document.getElementById('shader-indicator');
            const current = ScrollShaderManager.getCurrentShader();

            const names = {
                gs1: 'Topographic Flow',
                gs2: 'Glitch Technical',
                gs3: 'Dot Field'
            };

            if (current) {
                indicator.textContent = names[current] || current;
                if (ScrollShaderManager.isInTransition()) {
                    indicator.classList.add('transitioning');
                } else {
                    indicator.classList.remove('transitioning');
                }
            }
        }

        setInterval(updateIndicator, 100);

        // Initialize shader system
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                ScrollShaderManager.init();
            });
        } else {
            ScrollShaderManager.init();
        }
    </script>

    <!-- Config Form Manager (embedded inline) -->
    <script>
        // See config-form.html for standalone version
        // Embedded here to avoid fetch() issues with file:// protocol
        window.ConfigFormManager = (() => {
            let panelVisible = true;
            let currentShader = 'gs3';
            let currentInstance = null;
            let currentSection = null; // Track the active section element

            const panel = document.getElementById('shader-config-panel');
            const toggleBtn = document.getElementById('config-toggle-btn');
            const closeBtn = document.getElementById('close-panel-btn');
            const indicator = document.getElementById('current-shader-indicator');

            const PRESETS = {
                gs1: {
                    hero: { readTopoFlatten: 0.0, readWhiteBias: 0.0 },
                    ambient: { readTopoFlatten: 0.0, readWhiteBias: 0.0 },
                    read: { readTopoFlatten: 0.0, readWhiteBias: 0.0 }
                },
                gs2: {
                    hero: { calm: 0.05, flowDir: 0, readTopoFlatten: 0.0, readWhiteBias: 0.0 },
                    ambient: { calm: 0.45, flowDir: 45, readTopoFlatten: 0.0, readWhiteBias: 0.0 },
                    read: { calm: 0.85, flowDir: 90, readTopoFlatten: 0.0, readWhiteBias: 0.0 }
                },
                gs3: {
                    hero: { kGrid: 0.55, kJitter: 0.40, kSize: 0.60, kLaneFreq: 0.55, kLaneWobble: 0.55, kAlpha: 0.90, cursorInfluence: 0.25, seed: 13.7 },
                    ambient: { kGrid: 0.50, kJitter: 0.35, kSize: 0.55, kLaneFreq: 0.50, kLaneWobble: 0.45, kAlpha: 0.85, cursorInfluence: 0.20, seed: 13.7 },
                    read: { kGrid: 0.40, kJitter: 0.25, kSize: 0.45, kLaneFreq: 0.35, kLaneWobble: 0.25, kAlpha: 0.75, cursorInfluence: 0.15, seed: 13.7 }
                }
            };

            let metaControlsVisible = false;
            const DEFAULT_RANGES = new Map(); // Store original slider ranges

            function init() {
                bindToggleButton();
                bindCloseButton();
                bindMetaToggleButton();
                bindResetAllButton();
                bindKeyboardShortcut();
                restorePanelState();
                initMetaControls();

                // Find the first GS3 section to initialize with
                const firstSection = document.querySelector('.section[data-shader-system="gs3"]');
                showControlsFor('gs3', window.__BG3_INSTANCE__, firstSection);
            }

            function bindToggleButton() {
                if (!toggleBtn) return;
                toggleBtn.addEventListener('click', () => showPanel());
            }

            function bindCloseButton() {
                if (!closeBtn) return;
                closeBtn.addEventListener('click', () => hidePanel());
            }

            function bindKeyboardShortcut() {
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        togglePanel();
                    }
                });
            }

            function showPanel() {
                panelVisible = true;
                if (panel) panel.classList.remove('hidden');
                if (toggleBtn) toggleBtn.classList.remove('visible');
                savePanelState();
            }

            function hidePanel() {
                panelVisible = false;
                if (panel) panel.classList.add('hidden');
                if (toggleBtn) toggleBtn.classList.add('visible');
                savePanelState();
            }

            function togglePanel() {
                panelVisible ? hidePanel() : showPanel();
            }

            function savePanelState() {
                try {
                    localStorage.setItem('shaderConfigPanelVisible', panelVisible ? '1' : '0');
                } catch (e) { }
            }

            function restorePanelState() {
                try {
                    const saved = localStorage.getItem('shaderConfigPanelVisible');
                    saved === '0' ? hidePanel() : showPanel();
                } catch (e) { }
            }

            function showControlsFor(shaderId, instance, sectionElement) {
                currentShader = shaderId;
                currentInstance = instance;
                currentSection = sectionElement;

                if (indicator) indicator.textContent = shaderId.toUpperCase();

                document.querySelectorAll('.control-section').forEach(s => s.classList.remove('active'));
                const activeSection = document.querySelector(`.control-section[data-shader="${shaderId}"]`);
                if (activeSection) activeSection.classList.add('active');

                // Update mode-specific control visibility
                updateModeSpecificControls(shaderId, sectionElement);

                bindSliders(shaderId);
                loadSectionValues(); // Load values from the current section
                updateValueDisplays();
            }

            function updateModeSpecificControls(shaderId, sectionElement) {
                const section = document.querySelector(`.control-section[data-shader="${shaderId}"]`);
                if (!section) return;

                // Get the current mode from the section element
                const currentMode = sectionElement ? sectionElement.getAttribute('data-shader-mode') : null;

                // Show/hide mode-specific controls based on current mode
                section.querySelectorAll('label[data-mode]').forEach(label => {
                    const labelMode = label.getAttribute('data-mode');
                    if (currentMode && labelMode === currentMode) {
                        label.style.display = '';
                    } else {
                        label.style.display = 'none';
                    }
                });
            }

            function bindSliders(shaderId) {
                const section = document.querySelector(`.control-section[data-shader="${shaderId}"]`);
                if (!section) return;
                section.querySelectorAll('input[type="range"]').forEach(slider => {
                    const newSlider = slider.cloneNode(true);
                    slider.parentNode.replaceChild(newSlider, slider);
                    newSlider.addEventListener('input', (e) => {
                        updateParameter(e.target.dataset.attr, e.target.value, e.target.dataset.unit || '');
                    });
                });
            }

            function loadSectionValues() {
                if (!currentSection) return;

                const section = document.querySelector(`.control-section[data-shader="${currentShader}"]`);
                if (!section) return;

                section.querySelectorAll('input[type="range"]').forEach(slider => {
                    const attrName = slider.dataset.attr;
                    if (!attrName) return;

                    // First try to get value from localStorage
                    let value = getSectionValue(currentSection, attrName);

                    // If not found in localStorage, use section's data attribute
                    if (!value) {
                        value = currentSection.getAttribute(attrName);
                    }

                    if (value) {
                        // Remove unit suffix if present
                        const unit = slider.dataset.unit;
                        if (unit && value.endsWith(unit)) {
                            value = value.slice(0, -unit.length);
                        }
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            slider.value = numValue;

                            // CRITICAL: Apply the stored value back to the section HTML attribute
                            // so the shader actually uses it
                            const formattedValue = unit ? `${numValue}${unit}` : numValue.toString();
                            currentSection.setAttribute(attrName, formattedValue);
                        }
                    }
                });

                // After loading all values, trigger recomputation so shader picks up changes
                if (currentInstance && typeof currentInstance.computeScrollTargets === 'function') {
                    currentInstance.computeScrollTargets();
                }
            }

            function getSectionKey(section) {
                // Create unique key for section based on shader system, preset, and mode
                const shader = section.getAttribute('data-shader-system');
                const preset = section.getAttribute('data-shader-preset');
                const mode = section.getAttribute('data-shader-mode');
                return `section_${shader}_${preset}_${mode}`;
            }

            function saveSectionValue(section, attrName, value) {
                try {
                    const sectionKey = getSectionKey(section);
                    const storageKey = `${sectionKey}_${attrName}`;
                    localStorage.setItem(storageKey, value);
                } catch (e) { }
            }

            function getSectionValue(section, attrName) {
                try {
                    const sectionKey = getSectionKey(section);
                    const storageKey = `${sectionKey}_${attrName}`;
                    return localStorage.getItem(storageKey);
                } catch (e) {
                    return null;
                }
            }

            function updateParameter(attrName, value, unit) {
                if (!currentSection) return;

                const formattedValue = unit ? `${value}${unit}` : value;
                currentSection.setAttribute(attrName, formattedValue);

                // Save to localStorage for this specific section
                saveSectionValue(currentSection, attrName, formattedValue);

                if (currentInstance && typeof currentInstance.computeScrollTargets === 'function') {
                    currentInstance.computeScrollTargets();
                }
                updateValueDisplays();
                if (attrName === 'data-k-lane') updateLaneCount(parseFloat(value));
            }

            function updateValueDisplays() {
                const section = document.querySelector(`.control-section[data-shader="${currentShader}"]`);
                if (!section) return;
                section.querySelectorAll('input[type="range"]').forEach(slider => {
                    const uniformName = slider.dataset.uniform;
                    const display = section.querySelector(`[data-display="${uniformName}"]`);
                    const unit = slider.dataset.unit;
                    if (display) {
                        let displayValue = parseFloat(slider.value).toFixed(2);
                        if (unit) displayValue += unit;
                        if (uniformName === 'kLaneFreq') {
                            const laneSpan = display.querySelector('.lane-count');
                            if (laneSpan) display.childNodes[0].textContent = displayValue;
                            else display.textContent = displayValue;
                        } else {
                            display.textContent = displayValue;
                        }
                    }
                });
            }

            function updateLaneCount(laneFreqValue) {
                const laneCount = 3 + Math.floor(8.0 * laneFreqValue);
                const display = document.querySelector('[data-display="kLaneFreq"] .lane-count');
                if (display) display.textContent = `${laneCount} lanes`;
            }

            // ============================================
            // Meta-Controls Functions
            // ============================================

            function bindMetaToggleButton() {
                const metaToggleBtn = document.getElementById('meta-toggle-btn');
                if (!metaToggleBtn) return;
                metaToggleBtn.addEventListener('click', toggleMetaControls);
            }

            function toggleMetaControls() {
                metaControlsVisible = !metaControlsVisible;
                const metaToggleBtn = document.getElementById('meta-toggle-btn');

                document.querySelectorAll('.meta-controls').forEach(el => {
                    if (metaControlsVisible) {
                        el.classList.add('visible');
                    } else {
                        el.classList.remove('visible');
                    }
                });

                if (metaToggleBtn) {
                    if (metaControlsVisible) {
                        metaToggleBtn.classList.add('active');
                    } else {
                        metaToggleBtn.classList.remove('active');
                    }
                }

                try {
                    localStorage.setItem('metaControlsVisible', metaControlsVisible ? '1' : '0');
                } catch (e) { }
            }

            function initMetaControls() {
                // Store default ranges for all sliders
                document.querySelectorAll('input[type="range"][data-uniform]').forEach(slider => {
                    const uniform = slider.dataset.uniform;
                    if (!DEFAULT_RANGES.has(uniform)) {
                        DEFAULT_RANGES.set(uniform, {
                            min: slider.min,
                            max: slider.max,
                            step: slider.step,
                            defaultValue: slider.getAttribute('value') || slider.min
                        });
                    }
                });

                // Add meta-controls to each label
                document.querySelectorAll('.control-section label').forEach(label => {
                    const slider = label.querySelector('input[type="range"]');
                    if (!slider) return;

                    const uniform = slider.dataset.uniform;
                    const metaDiv = document.createElement('div');
                    metaDiv.className = 'meta-controls';
                    metaDiv.innerHTML = `
                        <div class="meta-controls-header">
                            <span>Range Settings</span>
                            <button class="reset-meta-btn" data-uniform="${uniform}">Reset</button>
                        </div>
                        <div class="meta-control-group">
                            <label>Min</label>
                            <input type="number" class="meta-min" data-uniform="${uniform}" value="${slider.min}" step="any">
                        </div>
                        <div class="meta-control-group">
                            <label>Max</label>
                            <input type="number" class="meta-max" data-uniform="${uniform}" value="${slider.max}" step="any">
                        </div>
                        <div class="meta-control-group">
                            <label>Step</label>
                            <input type="number" class="meta-step" data-uniform="${uniform}" value="${slider.step}" step="any">
                        </div>
                    `;
                    label.appendChild(metaDiv);
                });

                // Bind meta-control events
                bindMetaControlInputs();
                bindMetaResetButtons();

                // Restore saved meta-control state
                restoreMetaControlState();
            }

            function bindMetaControlInputs() {
                document.querySelectorAll('.meta-min, .meta-max, .meta-step').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const uniform = e.target.dataset.uniform;
                        const slider = document.querySelector(`input[type="range"][data-uniform="${uniform}"]`);
                        if (!slider) return;

                        const metaControls = e.target.closest('.meta-controls');
                        const minInput = metaControls.querySelector('.meta-min');
                        const maxInput = metaControls.querySelector('.meta-max');
                        const stepInput = metaControls.querySelector('.meta-step');

                        const newMin = parseFloat(minInput.value);
                        const newMax = parseFloat(maxInput.value);
                        const newStep = parseFloat(stepInput.value);

                        if (!isNaN(newMin)) slider.min = newMin;
                        if (!isNaN(newMax)) slider.max = newMax;
                        if (!isNaN(newStep) && newStep > 0) slider.step = newStep;

                        // Clamp current value to new range
                        const currentValue = parseFloat(slider.value);
                        if (currentValue < newMin) slider.value = newMin;
                        if (currentValue > newMax) slider.value = newMax;

                        // Save to localStorage
                        saveMetaControlState(uniform, newMin, newMax, newStep);
                        updateValueDisplays();
                    });
                });
            }

            function bindMetaResetButtons() {
                document.querySelectorAll('.reset-meta-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        const uniform = button.dataset.uniform;
                        const defaults = DEFAULT_RANGES.get(uniform);
                        if (!defaults) return;

                        const slider = document.querySelector(`input[type="range"][data-uniform="${uniform}"]`);
                        const metaControls = button.closest('.meta-controls');

                        if (slider && metaControls) {
                            slider.min = defaults.min;
                            slider.max = defaults.max;
                            slider.step = defaults.step;

                            metaControls.querySelector('.meta-min').value = defaults.min;
                            metaControls.querySelector('.meta-max').value = defaults.max;
                            metaControls.querySelector('.meta-step').value = defaults.step;

                            // Clear from localStorage
                            try {
                                localStorage.removeItem(`metaControl_${uniform}`);
                            } catch (e) { }

                            updateValueDisplays();
                        }
                    });
                });
            }

            function saveMetaControlState(uniform, min, max, step) {
                try {
                    localStorage.setItem(`metaControl_${uniform}`, JSON.stringify({ min, max, step }));
                } catch (e) { }
            }

            function restoreMetaControlState() {
                // Restore visibility state
                try {
                    const savedVisibility = localStorage.getItem('metaControlsVisible');
                    if (savedVisibility === '1') {
                        metaControlsVisible = true;
                        document.querySelectorAll('.meta-controls').forEach(el => el.classList.add('visible'));
                        const metaToggleBtn = document.getElementById('meta-toggle-btn');
                        if (metaToggleBtn) metaToggleBtn.classList.add('active');
                    }
                } catch (e) { }

                // Restore individual slider ranges
                DEFAULT_RANGES.forEach((defaults, uniform) => {
                    try {
                        const saved = localStorage.getItem(`metaControl_${uniform}`);
                        if (saved) {
                            const { min, max, step } = JSON.parse(saved);
                            const slider = document.querySelector(`input[type="range"][data-uniform="${uniform}"]`);
                            const metaControls = slider?.closest('label')?.querySelector('.meta-controls');

                            if (slider && metaControls) {
                                if (!isNaN(min)) {
                                    slider.min = min;
                                    metaControls.querySelector('.meta-min').value = min;
                                }
                                if (!isNaN(max)) {
                                    slider.max = max;
                                    metaControls.querySelector('.meta-max').value = max;
                                }
                                if (!isNaN(step) && step > 0) {
                                    slider.step = step;
                                    metaControls.querySelector('.meta-step').value = step;
                                }
                            }
                        }
                    } catch (e) { }
                });
            }

            function bindResetAllButton() {
                const resetAllBtn = document.getElementById('reset-all-btn');
                if (!resetAllBtn) return;
                resetAllBtn.addEventListener('click', resetAllValues);
            }

            function resetAllValues() {
                if (!currentSection || !currentShader) return;

                // Confirm reset
                if (!confirm('Reset all slider values and ranges for this section? This will clear saved settings from localStorage.')) {
                    return;
                }

                const section = document.querySelector(`.control-section[data-shader="${currentShader}"]`);
                if (!section) return;

                // Reset all sliders to defaults
                section.querySelectorAll('input[type="range"]').forEach(slider => {
                    const uniform = slider.dataset.uniform;
                    const defaults = DEFAULT_RANGES.get(uniform);

                    if (defaults) {
                        // Reset range settings
                        slider.min = defaults.min;
                        slider.max = defaults.max;
                        slider.step = defaults.step;

                        // Reset value to default (from HTML)
                        const defaultValue = slider.getAttribute('value') || defaults.min;
                        slider.value = defaultValue;

                        // Update meta-controls if they exist
                        const metaControls = slider.closest('label')?.querySelector('.meta-controls');
                        if (metaControls) {
                            metaControls.querySelector('.meta-min').value = defaults.min;
                            metaControls.querySelector('.meta-max').value = defaults.max;
                            metaControls.querySelector('.meta-step').value = defaults.step;
                        }

                        // Update the section's data attribute
                        const attrName = slider.dataset.attr;
                        const unit = slider.dataset.unit || '';
                        const formattedValue = unit ? `${defaultValue}${unit}` : defaultValue;
                        if (attrName) {
                            currentSection.setAttribute(attrName, formattedValue);
                        }
                    }
                });

                // Clear all localStorage for this section
                try {
                    const sectionKey = getSectionKey(currentSection);

                    // Clear section-specific values
                    section.querySelectorAll('input[type="range"]').forEach(slider => {
                        const attrName = slider.dataset.attr;
                        if (attrName) {
                            const storageKey = `${sectionKey}_${attrName}`;
                            localStorage.removeItem(storageKey);
                        }

                        // Clear meta-control settings
                        const uniform = slider.dataset.uniform;
                        localStorage.removeItem(`metaControl_${uniform}`);
                    });
                } catch (e) { }

                // Trigger recomputation and update displays
                if (currentInstance && typeof currentInstance.computeScrollTargets === 'function') {
                    currentInstance.computeScrollTargets();
                }
                updateValueDisplays();
            }

            return { init, showControlsFor, togglePanel, showPanel, hidePanel };
        })();

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => ConfigFormManager.init());
        } else {
            ConfigFormManager.init();
        }
    </script>

    <!-- FPS Counter Logic -->
    <script>
        (() => {
            const fpsCounter = document.getElementById('fps-counter');
            const fpsValueEl = document.getElementById('fps-value');
            const fpsMinEl = document.getElementById('fps-min');
            const fpsMaxEl = document.getElementById('fps-max');
            const fpsAvgEl = document.getElementById('fps-avg');

            let isVisible = false;
            let lastTime = performance.now();
            let frameCount = 0;
            let frameTimes = [];
            const FRAME_BUFFER_SIZE = 60; // Track last 60 frames for average

            let minFPS = Infinity;
            let maxFPS = 0;
            let lastFPSLevel = 'good'; // Track FPS level to detect changes

            function getActiveShaderContext() {
                const currentShader = ScrollShaderManager?.getCurrentShader() || 'unknown';
                const currentSection = ScrollShaderManager?.getCurrentSection?.();

                let mode = 'unknown';
                let preset = 'unknown';

                if (currentSection) {
                    // Read preset from data attribute (hero/ambient/read)
                    preset = currentSection.getAttribute('data-shader-preset') || 'unknown';

                    // Read mode from data attribute (glitch-grid/vector-glitch/signal-flow, etc.)
                    mode = currentSection.getAttribute('data-shader-mode') || 'unknown';
                }

                return { shader: currentShader, mode, preset };
            } function measureFPS() {
                const now = performance.now();
                const delta = now - lastTime;
                lastTime = now;

                if (delta > 0) {
                    const currentFPS = 1000 / delta;

                    // Track min/max
                    minFPS = Math.min(minFPS, currentFPS);
                    maxFPS = Math.max(maxFPS, currentFPS);

                    // Store frame time for rolling average
                    frameTimes.push(currentFPS);
                    if (frameTimes.length > FRAME_BUFFER_SIZE) {
                        frameTimes.shift();
                    }

                    // Update display every 10 frames to avoid jitter
                    frameCount++;
                    if (frameCount >= 10) {
                        frameCount = 0;
                        updateDisplay(currentFPS);
                    }
                }

                requestAnimationFrame(measureFPS);
            }

            function updateDisplay(currentFPS) {
                const avgFPS = frameTimes.reduce((sum, fps) => sum + fps, 0) / frameTimes.length;

                // Update values
                fpsValueEl.textContent = Math.round(currentFPS);
                fpsMinEl.textContent = Math.round(minFPS);
                fpsMaxEl.textContent = Math.round(maxFPS);
                fpsAvgEl.textContent = Math.round(avgFPS);

                // Determine FPS level
                let currentLevel = 'good';
                if (currentFPS < 30) {
                    currentLevel = 'bad';
                } else if (currentFPS < 50) {
                    currentLevel = 'medium';
                }

                // Log when FPS level degrades
                if (currentLevel !== lastFPSLevel && (currentLevel === 'medium' || currentLevel === 'bad')) {
                    const context = getActiveShaderContext();
                    console.warn(`‚ö†Ô∏è FPS dropped to ${currentLevel.toUpperCase()}:`, {
                        fps: Math.round(currentFPS),
                        avgFPS: Math.round(avgFPS),
                        shader: context.shader,
                        mode: context.mode,
                        preset: context.preset,
                        timestamp: new Date().toISOString()
                    });
                }

                lastFPSLevel = currentLevel;

                // Color-code based on current FPS
                fpsCounter.classList.remove('fps-good', 'fps-medium', 'fps-bad');
                if (currentFPS >= 50) {
                    fpsCounter.classList.add('fps-good');
                } else if (currentFPS >= 30) {
                    fpsCounter.classList.add('fps-medium');
                } else {
                    fpsCounter.classList.add('fps-bad');
                }
            }

            function toggleVisibility() {
                isVisible = !isVisible;
                console.log('FPS Counter toggle:', isVisible, 'classList:', fpsCounter.className);
                if (isVisible) {
                    fpsCounter.classList.add('show');
                    // Reset stats when showing
                    minFPS = Infinity;
                    maxFPS = 0;
                    frameTimes = [];
                    frameCount = 0;
                } else {
                    fpsCounter.classList.remove('show');
                }
            }

            // 'f' key toggle
            document.addEventListener('keydown', (e) => {
                if (e.key === 'f' || e.key === 'F') {
                    // Don't trigger if typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    e.preventDefault();
                    console.log('F key pressed, toggling FPS counter');
                    toggleVisibility();
                }
            });

            // Start measuring
            requestAnimationFrame(measureFPS);
        })();
    </script>
</body>

</html>